using System;
using System.ServiceModel;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Management;
using System.Diagnostics;
using System.Security.Cryptography.X509Certificates;
using Interfaces;
using System.Reflection;
using System.Security.Cryptography;
using System.IO;
using System.Collections.Concurrent;
using System.Threading;

using System.Security.Principal;
using System.Security;
using System.IdentityModel;
using Common;
using System.Security.Cryptography;

namespace ClientTests
{
    class ClientFalseCert : ChannelFactory<IAntiMalwareService>, IClient, IAntiMalwareService, IDisposable
    {
        private int isEventClient = 1;
        private ConcurrentQueue<byte[]> requests;
        private Boolean exit = false;
        private IAntiMalwareService factory;
        private Dictionary<EndpointAddress, Boolean> endPointAddreses = new Dictionary<EndpointAddress, bool>();
        NetTcpBinding binding;
        private byte[] key1 = new byte[8];
        private byte[] key2 = new byte[8];
        private byte[] vector = new byte[8];
        private byte[] newVal = new Byte[32];
        X509Certificate2 clientCertificate;
        X509Certificate2 serverCertificate;
        Thread validateRequestsThread;

        public ClientFalseCert(NetTcpBinding binding, EndpointAddress address)
            : base(binding, address)
        {
            
            string cltCertCN = "wcfclientfalse";
            /*
            this.Credentials.ServiceCertificate.Authentication.CertificateValidationMode = System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust;
            this.Credentials.ServiceCertificate.Authentication.RevocationMode = X509RevocationMode.NoCheck;


            /// Set appropriate client's certificate on the channel. Use CertManager class to obtain the certificate based on the "cltCertCN"
            this.Credentials.ClientCertificate.Certificate = Certificate.GetCertificateFromStorage(StoreName.My, StoreLocation.LocalMachine, cltCertCN);
            clientCertificate = this.Credentials.ClientCertificate.Certificate;
             */
            factory = this.CreateChannel();


            requests = new ConcurrentQueue<byte[]>();
            validateRequestsThread = new Thread(validateRequests);

            validateRequestsThread.Start();
        }
        private byte[] TrimEnd(byte[] array)
        {
            int lastIndex = Array.FindLastIndex(array, b => b != 0);

            Array.Resize(ref array, lastIndex + 1);

            return array;
        }
        private void validateRequests()
        {
            byte[] outvalue;
            Boolean tryedReconnecting = false;
            while (!exit)
            {
                while (Requests.TryDequeue(out outvalue))
                {
                    try
                    {
                        System.Buffer.BlockCopy(outvalue, 0, this.newVal, 0, outvalue.Length);
                        Logger.LogSuccess("Enkriptovan je hash.");
                        Console.WriteLine("Encrypting hash!");
                        RSACrypting.writeHash(outvalue);
                        
                        ITripleDES tdes = new Security.TripleDES();
                        byte[] resultArray = tdes.encrypt(outvalue, key1, key2, vector);

                        Byte[] isval = isValid(resultArray);
                        if (tryedReconnecting)
                        {
                            for (int i = endPointAddreses.Count - 1; i >= 0; i--)
                            {
                                var item = endPointAddreses.ElementAt(i);
                                var itemKey = item.Key;
                                var itemValue = item.Value;
                                if (itemValue == false)
                                {
                                    endPointAddreses[itemKey] = true;
                                }
                                else if (itemValue == true)
                                {
                                    endPointAddreses[itemKey] = false;
                                }
                            }
                            tryedReconnecting = false;
                        }
                        if (isval != null)
                        {

                            Console.WriteLine("Treba dekriptovati: ");
                            RSACrypting.writeHash(isval);

                            String message = RSACrypting.GetString(tdes.decrypt(isval, key1, key2, vector));
                            var cleaned = message.Replace("\0", string.Empty);
                            if (cleaned.Equals("false"))
                            {
                                Logger.LogInformation("Aplikacija ne postoji u whitelisti!");
                                Console.WriteLine("NE POSTOJI U WHITE LISTI!");
                            }
                            else
                            {
                                Logger.LogInformation("Aplikacija [ " + message + " ] se nalazi u white listi.");
                                Console.WriteLine("Aplikacija [ " + message + " ] se nalazi u whitelisti!");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("Vracam hash!");
                        RSACrypting.writeHash(this.newVal);
                        RSACrypting.writeHash(outvalue);
                        Requests.Enqueue(this.newVal);
                        Logger.LogFailure("Server je crkao.");
                        Console.WriteLine("Server mi je crkao! Ucini prevezivanje!");
                        int iResult = tryReconnect();
                        if(iResult == -1){
                            exit = true;
                        }
                        if (tryedReconnecting == true)
                        {
                            exit = true;
                        }
                        tryedReconnecting = true;
                        break;
                    }
                }
            }
        }
        private int tryReconnect()
        {
            Logger.LogInformation("Pokusaj prevezivanje na drugi server.");
            Stopwatch sw = new Stopwatch();
            sw.Start();
            sw.Stop();
            while(sw.ElapsedMilliseconds < 5000){
                sw.Start();
                try{

                    foreach (KeyValuePair<EndpointAddress, Boolean> pair in endPointAddreses)
                    {
                        if (pair.Value == false)
                        {
                            factory = this.CreateChannel(pair.Key);
                            Byte[] data = new Byte[24];
                            
                            System.Buffer.BlockCopy(key1, 0, data, 0, 8);
                            System.Buffer.BlockCopy(key2, 0, data, 8, 8);
                            System.Buffer.BlockCopy(vector, 0, data, 16, 8);

                            X509Certificate2 cert = factory.getCertificate();
                            RSACryptoServiceProvider publicKeyProvider = (RSACryptoServiceProvider)cert.PublicKey.Key;

                            Byte[] forDecryptiong = publicKeyProvider.Encrypt(data, true);
                            Console.WriteLine("-- DRUGI HANDSHAKE --");
                            RSACrypting.writeHash(key1);
                            RSACrypting.writeHash(key2);
                            RSACrypting.writeHash(vector);

                            RSACrypting.writeHash(data);
                            Console.WriteLine("-- DRUGI HANDSHAKE --");

                            Byte[] response = factory.exchangeData(forDecryptiong);
                            Byte[] decrypted = null;
                            if (response != null)
                            {
                                ITripleDES tdes = new Security.TripleDES();
                                decrypted = tdes.decrypt(response, key1, key2, vector);
                                String str = RSACrypting.GetString(decrypted);
                                RSACrypting.writeHash(response);

                                var cleaned = str.Replace("\0", string.Empty);
                                if (cleaned.Equals("OK"))
                                {
                                    Logger.LogSuccess("Handshake uspesan.");
                                    Console.WriteLine("Handshake uspesan!");
                                    return 0;
                                }
                                else
                                {
                                    Logger.LogFailure("Handshake nije bio uspesan. Pokusajte ponovo da pokrenete aplikaciju i da imate odgovarajuce privilegije.");
                                    Console.WriteLine("Handshake nije bio uspesan! \nPokusajte ponovo da pokrenetre aplikaciju i da imate odogovarajuce privilegije!");
                                    return -1;
                                }

                            }

                            
                        }
                    }

                 
                }catch(Exception){
                    Logger.LogWarning("Nemate kreiran Key Value pair sa endpoint adresama.");
                    sw.Stop();
                }
            }

            Logger.LogFailure("Nemoguca je uspostava konekcije sa serverom. Zatvara se..");
            Console.WriteLine("Ne mogu vise da uspostavim konekciju sa serverom! Zatvaram se...");
            return -1;
        }
        public ClientFalseCert() { }
        /// <summary>
        /// This method is used to make encrypted message based on TripleDES algorithm. 
        /// <para>data</para> is byte array that represents digital signature that needs to be encrypted.
        /// </summary>
        /// <returns>encrypted digital signature</returns>
        public byte[] encrypt()
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// This method is used in order to get signature from the applications.
        /// It is based on isEventClient field of the Client class. isEventClient gets its value from the
        /// command line argument. If its value is 1 it means that client waits for applications to start. 
        /// If it is any other value it means that user needs to input path to the .exe file.
        /// </summary>
        public int getSignature()
        {
            if (isEventClient == 1)
            {
                watch();
            }
            else
            {
                getProcessByPath();
            }
            return 0;

        }
        /// <summary>
        /// This method finds certificate based on the location of the .exe or .dll.
        /// </summary>
        private void getProcessByPath()
        {
            Logger.LogInformation("Prosledjivanje putanje do odredjenog fajla na disku za koji je potrebno proveriti da li je validan.");
            String path = null;
            do
            {
                Console.WriteLine("Unesite punu putanju do .exe ili .dll > \n (Za izlaz napisite exit)");
                path = Console.ReadLine();

                if (File.Exists(path))
                {
                    byte[] data = sha256AppHashe(path);
                    if (data != null)
                    {
                        /*
                        StringBuilder hex = new StringBuilder(data.Length * 2);
                        foreach (byte b in data)
                            hex.AppendFormat("{0:x2}", b);
                        
                        Console.WriteLine(hex.ToString());
                        File.AppendAllText(@"C:\Users\mihailo\Desktop\hashes.txt", hex.ToString() + Environment.NewLine);
                       // Console.WriteLine(System.Text.Encoding.UTF8.GetString(data));
                       */
                        requests.Enqueue(data);
                        Logger.LogInformation("Stavlja se hash unetog fajla u konkurentni red.");
                    }

                    Console.WriteLine("Uradio sam.");
                }
                else
                {
                    Logger.LogError("Neispravna putanja do fajla.");
                    Console.WriteLine("Niste uneli validnu putanju do fajla.");
                }

            } while (!path.Equals("exit"));
        }

        /// <summary>
        /// This method is used in order to produce events as applications starts or stops.
        /// ManagementEventWatcher class is used in order to subscribe to temporary event notifications based on a specified event query.
        /// WqlEventQuery class is used in order to make WMI( Infrastructure for accessing operations and data in Windows)
        /// event query in WQL(SQL for WMI) format. 
        /// Win32_ProcessStartTrace class indicates that new process is started. 
        /// When event arrives, startWatch_EventArrived handler is called to process it. 
        /// When client closes the application, handlers are stoping.
        /// </summary>
        private void watch()
        {
            Logger.LogInformation("Pravi se proces aplikacije koja je pokrenuta.");
            //ManagementEventWatcher startWatch = new ManagementEventWatcher(new WqlEventQuery("SELECT * FROM Win32_ProcessStartTrace"));
            //startWatch.EventArrived += new EventArrivedEventHandler(startWatch_EventArrived);
            //startWatch.Start();
            Console.WriteLine("Press any key to exit");
            while (!Console.KeyAvailable) System.Threading.Thread.Sleep(50);
            //startWatch.Stop();
        }
        /// <summary>
        /// This method is used in order to process application starting event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        /*private void startWatch_EventArrived(object sender, EventArrivedEventArgs e)
        {
            Logger.LogInformation("Proces " + e.NewEvent.Properties["ProcessName"].Value + " je startovan");
            Console.WriteLine("Process started: {0}", e.NewEvent.Properties["ProcessName"].Value);
            Process process = getProcess(makeName(e.NewEvent.Properties["ProcessName"].Value.ToString()));
            if (process != null)
            {
                byte[] data = sha256AppHashe(process.MainModule.FileName);
                Console.WriteLine(System.Text.Encoding.UTF8.GetString(data));

                if (data != null)
                {
                    
                  
                    requests.Enqueue(data);
                    Logger.LogInformation("Stavlja se hash unetog fajla u konkurentni red.");
                }


                Console.WriteLine("Uradio sam.");
            }
        }*/
        private byte[] sha256AppHashe(String path)
        {
            FileStream filestream;
            SHA256 mySHA256 = SHA256Managed.Create();
            try
            {
                filestream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                filestream.Position = 0;

                byte[] hashValue = mySHA256.ComputeHash(filestream);

                Logger.LogSuccess("Vracen je hash za uneti fajl.");
                return hashValue;
            }
            catch (Exception ex)
            {
                Logger.LogFailure("Fajl koji je unet je vec otvoren.");
                Console.WriteLine("Fajl vec otvoren!");
                return null;
            }

        }
        /// <summary>
        /// Based on started event and its full name( having .exe in the end) it is making name without .exe.
        /// </summary>
        /// <param name="wholeName"></param>
        /// <returns>name without .exe</returns>
        private String makeName(String wholeName)
        {
            return wholeName.Substring(0, wholeName.Length - 4);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="name"></param>
        /// <returns>process if it exists, NULL if the process doesn't exist!</returns>
        private Process getProcess(String name)
        {
            Process retVal = null;
            try
            {
                retVal = Process.GetProcessesByName(name)[0];
            }
            catch (Exception ex)
            {
                Logger.LogWarning("Ne postoji proces koji je startovan sa trazenim imenom.");
                Console.WriteLine("There is no process started by the given name.");
            }
            return retVal;
        }
        /// <summary>
        /// Property for setting isEventClient field.
        /// </summary>
        public int IsEventClient
        {
            get
            {
                return isEventClient;
            }
            set
            {
                isEventClient = value;
            }
        }

        public Byte[] isValid(Byte[] hash)
        {
            try
            {
                return factory.isValid(hash);
                
            }
            catch (Exception ex)
            {
                throw ex;
            }

        }

        public byte[] exchangeData(byte[] data)
        {
            try
            {
                /*

                    RSA CRYPTING KEYS AND VECTOR
                 */
                Logger.LogInformation("Sifrovanje kljuceva i vektora sa rsa algoritmom.");
                X509Certificate2 cert = Certificate.GetCertificateFromStorage(StoreName.My, StoreLocation.LocalMachine, "wcfservice");
                data = RSACrypting.TripleDESRandomGenerator();
                byte[] encrypted = RSACrypting.RSAencrypt(cert, data);

                System.Buffer.BlockCopy(data, 0, key1, 0, 8);
                System.Buffer.BlockCopy(data, 8, key2, 0, 8);
                System.Buffer.BlockCopy(data, 16, vector, 0, 8);
                Console.WriteLine("-- PRVI HANDSHAKE --");
                RSACrypting.writeHash(key1);
                RSACrypting.writeHash(key2);
                RSACrypting.writeHash(vector);
                Console.WriteLine("-- PRVI HANDSHAKE --");
                Byte[] response = factory.exchangeData(encrypted);
                Byte[] decrypted = null;
                if (response != null) { 
                    ITripleDES tdes = new Security.TripleDES();
                    decrypted = tdes.decrypt(response, key1, key2, vector);
                    String str = RSACrypting.GetString(decrypted);
                    RSACrypting.writeHash(response);
                }
                return decrypted; 
            }
            catch (Exception ex)
            {
                Logger.LogError("Desio se exception prilikom metode exchange data. Nije moguce kriptovati kljuceve i vektor rsa algoritmom.");
                Console.WriteLine(ex.StackTrace);
                return null;
            }
        }

        public ConcurrentQueue<byte[]> Requests
        {
            get
            {
                return requests;
            }
            set
            {
                requests = value;
            }
        }

        public Dictionary<EndpointAddress, Boolean> EndPointAddreses
        {
            get
            {
                return endPointAddreses;
            }
            set
            {
                endPointAddreses = value;
            }
        }

        public NetTcpBinding Binding
        {
            get
            {
                return binding;
            }
            set
            {
                binding = value;
            }
        }
        public X509Certificate2 getCertificate()
        {
            serverCertificate = factory.getCertificate();
            return serverCertificate;
        }
        public X509Certificate2 ClientCertificate
        {
            get
            {
                return clientCertificate;
            }
            set
            {
                clientCertificate = value;
            }
        }

        public X509Certificate2 ServerCertificate
        {
            get
            {
                return serverCertificate;
            }
            set
            {
                serverCertificate = value;
            }
        }
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Interfaces;
using Repository;
using MySql.Data.MySqlClient;
using System.Security.Principal;
using System.Security;
using Common;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using Security;
using System.ServiceModel;

namespace Server
{
    [ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession,
                 ConcurrencyMode = ConcurrencyMode.Single)]
    public class Service : IReplicator, IAntiMalwareService, IDisposable
    {
        Dictionary<String, String> whiteList;
        IRepository repository;
        String schemeName;

        ServiceData serviceData;
        private readonly Dependencies _dependencies;
        X509Certificate2 clientCertificate;
        X509Certificate2 serverCertificate;
        // set this before creating service host. this can use your IOC container or whatever.
        // if you don't like the mutability shown here (IoC containers are usually immutable after being configured)
        // you can use some sort of write-once object
        // or more advanced approach like authenticated access
        public static Func<Dependencies> GetDependencies { get; set; }
        public class Dependencies
        {
            // whatever your service needs here.
            public String SchemeName { get; set; }

            public Dependencies(String schemeName)
            {
                SchemeName = schemeName;
            }
        }

        public Service() 
        {

          //  _dependencies = GetDependencies();
            repository = new DBRepository("localhost", "white_list" , "root", "root");
            whiteList = new Dictionary<String, String>();
            serviceData = new ServiceData();
            serverCertificate = Certificate.GetCertificateFromStorage(StoreName.My, StoreLocation.LocalMachine, "wcfservice");

        }

        public Service(IRepository repository)
        {
            this.repository = repository;
        }


        public DBRepository getRepository() 
        {
            return repository as DBRepository;
        
        }

        public Byte[] isValid(Byte[] hash)
        {
            Console.WriteLine("Klijent hoce da sazna nesto!");
            Logger.LogInformation("Klijent hoce da sazna nesto.");

            /*
                Triple des!
                */
            ITripleDES tdes = new Security.TripleDES();
            byte[] resultArray = tdes.decrypt(hash, serviceData.Key1, serviceData.Key2, serviceData.IV);
            Console.WriteLine("Decrypted hash!");
            Logger.LogSuccess("Dekriptovan je hash.");
            RSACrypting.writeHash(resultArray);

       

            try
            {
                KeyValuePair<String, String> whiteList = repository.checkHash(resultArray);
                if(whiteList.Key == null)
                {
                    Byte[] data1 = tdes.encrypt(RSACrypting.GetBytes("false"), serviceData.Key1, serviceData.Key2, serviceData.IV);
                    return data1;
                }

                Byte[] data = tdes.encrypt(RSACrypting.GetBytes(whiteList.Value), serviceData.Key1, serviceData.Key2, serviceData.IV);
                Logger.LogSuccess("Kriptovan je odgovor.");
                Console.WriteLine("Kriptovan odgovor: ");
                RSACrypting.writeHash(data);

                return data;
            }
            catch (KeyNotFoundException ex)
            {
                Logger.LogError("Kljuc nije pronadjen.");
               Byte[] data = tdes.encrypt(RSACrypting.GetBytes("false"), serviceData.Key1, serviceData.Key2, serviceData.IV);

                return data;
            }


        }

        private String makeMessage(KeyValuePair<String, String> pair)
        {

            StringBuilder sb = new StringBuilder();

            sb.Append("true");
            sb.Append(":");
            sb.Append(pair.Value);

            return sb.ToString();

        }
        private String makeMessage()
        {
                return "false";
        }
        public bool isAlive()
        {
            return true;
        }

        public Dictionary<String, String> update()
        {
            MySqlCommand cmd;

            Dictionary<String, String> dict = new Dictionary<String, String>();
            string name;
            string hash;
            Logger.LogInformation("Citaju se podaci iz baze i popunjava recnik sa svim podacima.");
            try
            {
                cmd = getRepository().getConnection().MysqlConn.CreateCommand();
                string query = "SELECT * FROM whitelist";

                List<string> nameList = new List<string>();
                List<string> hashList = new List<string>();

                //Create Command
                cmd = new MySqlCommand(query, getRepository().getConnection().MysqlConn);
                //Create a data reader and Execute the command
                MySqlDataReader dataReader = cmd.ExecuteReader();

                //Read the data and store them in the list
                while (dataReader.Read())
                {
                    name = dataReader["name"] + "";
                    hash = dataReader["hash"] + "";

                    dict.Add(name, hash);
                }

                //close Data Reader
                dataReader.Close();

            }
            catch (Exception ex)
            {
                Logger.LogError("Nije moguce procitati podatke iz baze, niti uspostaviti konekciju sa bazom. Proverite konekciju sa bazom..");
                Console.WriteLine(ex.Message);
            }

            return dict;
        }
        
        public byte[] exchangeData(byte[] data)
        {
            X509Certificate2 cert = Certificate.GetCertificateFromStorage(StoreName.My, StoreLocation.LocalMachine, "wcfservice"); 
            Byte[] decryptedDAta = RSACrypting.RSAdecrypt(cert, data);
            byte[] test = new byte[8];
            System.Buffer.BlockCopy(decryptedDAta, 0, test, 0, 8);
            serviceData.Key1 = createArray(test);
            System.Buffer.BlockCopy(decryptedDAta, 8, test, 0, 8);
            serviceData.Key2 = createArray(test);
            System.Buffer.BlockCopy(decryptedDAta, 16, test, 0, 8);
            serviceData.IV = createArray(test);
            Console.WriteLine("-- DRUGI HANDSHAKE SERVIS--");


            RSACrypting.writeHash(serviceData.Key1);
            RSACrypting.writeHash(serviceData.Key2);
            RSACrypting.writeHash(serviceData.IV);
            Console.WriteLine("-- DRUGI HANDSHAKE --");
            ITripleDES tdes = new Security.TripleDES();

            String str = "OK";

            return tdes.encrypt(RSACrypting.GetBytes(str), serviceData.Key1, serviceData.Key2, serviceData.IV);
        }

        private byte[] createArray( byte[] data)
        {
            byte[]array = new byte[8];
            System.Buffer.BlockCopy(data, 0, array, 0, 8);
            return array;
        }

        public X509Certificate2 getCertificate()
        {
                    
                return serverCertificate;
        }
        // Flag: Has Dispose already been called?
        bool disposed = false;
        // Instantiate a SafeHandle instance.

        // Public implementation of Dispose pattern callable by consumers.
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        // Protected implementation of Dispose pattern.
        protected virtual void Dispose(bool disposing)
        {
            if (disposed)
                return;

            if (disposing)
            {
                ((DBRepository)repository).getConnection().close();
            }

            // Free any unmanaged objects here.
            //
            disposed = true;
        }

        public X509Certificate2 ServerCertificate
        {
            get
            {
                return serverCertificate;
            }
            set
            {
                serverCertificate = value;
            }
        }
        public X509Certificate2 ClientCertificate
        {
            get
            {
                return clientCertificate;
            }
            set
            {
                clientCertificate = value;
            }
        }


    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Interfaces;
using Repository;
using MySql.Data.MySqlClient;
using System.Security.Principal;
using System.Security;
using Common;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using Security;
namespace Server
{
    public class Service : IReplicator, IAntiMalwareService
    {
        Dictionary<String, String> whiteList;
        IRepository repository;
        String schemeName;
        private byte[] key1 = new byte[8];
        private byte[] key2 = new byte[8];
        private byte[] vector = new byte[8];
        private readonly Dependencies _dependencies;

        // set this before creating service host. this can use your IOC container or whatever.
        // if you don't like the mutability shown here (IoC containers are usually immutable after being configured)
        // you can use some sort of write-once object
        // or more advanced approach like authenticated access
        public static Func<Dependencies> GetDependencies { get; set; }
        public class Dependencies
        {
            // whatever your service needs here.
            public String SchemeName { get; set; }

            public Dependencies(String schemeName)
            {
                SchemeName = schemeName;
            }
        }

        public Service() 
        {

          //  _dependencies = GetDependencies();
            repository = new DBRepository("localhost", "white_list" , "root", "root");
            whiteList = new Dictionary<String, String>();

        }

        public Service(IRepository repository)
        {
            this.repository = repository;
        }


        public DBRepository getRepository() 
        {
            return repository as DBRepository;
        
        }

        public Byte[] isValid(Byte[] hash)
        {
            Console.WriteLine("Klijent hoce da sazna nesto!");


            /*
                Triple des!
                */
            ITripleDES tdes = new MSTripleDES();
            byte[] resultArray = new byte[32];
            resultArray = tdes.decrypt(hash, key1, key2, vector);
            Console.WriteLine("Decrypted hash!");
            RSACrypting.writeHash(resultArray);

            /*
            Console.WriteLine("Dobio sam: ");
            StringBuilder hex = new StringBuilder(resultArray.Length * 2);
            foreach (byte b in resultArray)
                hex.AppendFormat("{0:x2}", b);

            Console.WriteLine(hex.ToString());
            byte[] key1 = new byte[8];
            byte[] key2 = new byte[8];
            byte[] vector = new byte[8];

            // DEKRIPCIJA PORUKE KOJA DODJE  hash  3DES 
            Byte[] message = new Byte[64];
            try
            {
                KeyValuePair<String, String> whiteList = repository.checkHash(hash);
            }
            catch (KeyNotFoundException ex)
            {
                // nije pronasao
            }
             //crypt(message)
            X509Certificate2 clientCert = Certificate.GetCertificateFromStorage(StoreName.My, StoreLocation.LocalMachine, "wcfclient");
            Byte[] keys = RSACrypting.RSAencrypt(clientCert);
            Byte[] toSend = new Byte[keys.Length + message.Length];
            System.Buffer.BlockCopy(toSend, 0, keys, 0, 24);
            System.Buffer.BlockCopy(toSend, 0, message, 24, message.Length);
            */
            return null;
        }


        public bool isAlive()
        {
            return true;
        }

        public Dictionary<String, String> update()
        {
            MySqlCommand cmd;

            Dictionary<String, String> dict = new Dictionary<String, String>();
            string name;
            string hash;

            try
            {
                cmd = getRepository().getConnection().MysqlConn.CreateCommand();
                string query = "SELECT * FROM whitelist";

                List<string> nameList = new List<string>();
                List<string> hashList = new List<string>();

                //Create Command
                cmd = new MySqlCommand(query, getRepository().getConnection().MysqlConn);
                //Create a data reader and Execute the command
                MySqlDataReader dataReader = cmd.ExecuteReader();

                //Read the data and store them in the list
                while (dataReader.Read())
                {
                    name = dataReader["name"] + "";
                    hash = dataReader["hash"] + "";

                    dict.Add(name, hash);
                }

                //close Data Reader
                dataReader.Close();

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

            return dict;
        }

        public byte[] exchangeData(byte[] data)
        {
            X509Certificate2 cert = Certificate.GetCertificateFromStorage(StoreName.My, StoreLocation.LocalMachine, "wcfservice");
            Byte[] decryptedDAta = RSACrypting.RSAdecrypt(cert, data);

            System.Buffer.BlockCopy(data, 0, key1, 0, 8);
            System.Buffer.BlockCopy(data, 8, key2, 0, 8);
            System.Buffer.BlockCopy(data, 16, vector, 0, 8);

            ITripleDES tdes = new Security.TripleDES();

            String str = "OKOK";

            return tdes.encrypt(GetBytes(str), key1, key2, vector);
        }
        private byte[] GetBytes(string str)
        {
            byte[] bytes = new byte[str.Length * sizeof(char)];
            System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
            return bytes;
        }
    }
}

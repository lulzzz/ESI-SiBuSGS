using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Interfaces;

namespace Security
{
    class TripleDES : ITripleDES
    {

		private byte[] data;	// the entire data to be encrypted

		private byte[] cryptingBlock;	// the block upon which the encryption has to be done
		private byte[] leftHalf;
		private byte[] rightHalf;
		private byte[] encryptedBlock;
        private byte[] previousEncriptedBlock;
		
		public void encrypt(byte[] data, byte[] key1, byte[] key2, byte[] initizationVector, byte[] encryptedData)
        {
			//TODO: Implement
			//throw new NotImplementedException();
			if ((data.Length % 8) != 0)
			{
				throw new ArgumentException("data argument must be devidable with 8");
			}

			this.data = data;	// entire data that has to be cyphered
            // get one by one block from here


            // when you get the block 
            encryptedBlock = cryptingBlock;

			//TODO: XOR the first block with the initizationVector
			//here
			encryptBlock();

			for (int i = 1; i < ((data.Length) / 8); ++i)
			{
				//TODO: XOR the block with the previous block
				//here
				encryptBlock();
			}			
        }

		private void encryptBlock()
		{
			// let the encryption begin
			initialPermutation();
			splitBlock();
			for (int i = 0; i < 16; i++)
			{
				functionF();
			}
            previousEncriptedBlock = encryptedBlock;
			inversePermutation();
		}

		public void decrypt(byte[] encryptedData, byte[] key1, byte[] key2, byte[] initizationVector, byte[] decryptedData)
        {			
			encrypt(encryptedData, key1, key2, initizationVector, decryptedData);
        }

		private void initialPermutation()
		{
            byte[] temp = new byte[] {
              (byte)((((cryptingBlock[7]>>6)&1)<<7) + (((cryptingBlock[6]>>6)&1)<<6) + (((cryptingBlock[5]>>6)&1)<<5) + (((cryptingBlock[4]>>6)&1)<<4) + (((cryptingBlock[3]>>6)&1)<<3) + (((cryptingBlock[2]>>6)&1)<<2) + (((cryptingBlock[1]>>6)&1)<<1) + (((cryptingBlock[0]>>6)&1)<<0)),
              (byte)((((cryptingBlock[7]>>4)&1)<<7) + (((cryptingBlock[6]>>4)&1)<<6) + (((cryptingBlock[5]>>4)&1)<<5) + (((cryptingBlock[4]>>4)&1)<<4) + (((cryptingBlock[3]>>4)&1)<<3) + (((cryptingBlock[2]>>4)&1)<<2) + (((cryptingBlock[1]>>4)&1)<<1) + (((cryptingBlock[0]>>4)&1)<<0)),
              (byte)((((cryptingBlock[7]>>2)&1)<<7) + (((cryptingBlock[6]>>2)&1)<<6) + (((cryptingBlock[5]>>2)&1)<<5) + (((cryptingBlock[4]>>2)&1)<<4) + (((cryptingBlock[3]>>2)&1)<<3) + (((cryptingBlock[2]>>2)&1)<<2) + (((cryptingBlock[1]>>2)&1)<<1) + (((cryptingBlock[0]>>2)&1)<<0)),
              (byte)((((cryptingBlock[7]>>0)&1)<<7) + (((cryptingBlock[6]>>0)&1)<<6) + (((cryptingBlock[5]>>0)&1)<<5) + (((cryptingBlock[4]>>0)&1)<<4) + (((cryptingBlock[3]>>0)&1)<<3) + (((cryptingBlock[2]>>0)&1)<<2) + (((cryptingBlock[1]>>0)&1)<<1) + (((cryptingBlock[0]>>0)&1)<<0)),
              (byte)((((cryptingBlock[7]>>7)&1)<<7) + (((cryptingBlock[6]>>7)&1)<<6) + (((cryptingBlock[5]>>7)&1)<<5) + (((cryptingBlock[4]>>7)&1)<<4) + (((cryptingBlock[3]>>7)&1)<<3) + (((cryptingBlock[2]>>7)&1)<<2) + (((cryptingBlock[1]>>7)&1)<<1) + (((cryptingBlock[0]>>7)&1)<<0)),
              (byte)((((cryptingBlock[7]>>5)&1)<<7) + (((cryptingBlock[6]>>5)&1)<<6) + (((cryptingBlock[5]>>5)&1)<<5) + (((cryptingBlock[4]>>5)&1)<<4) + (((cryptingBlock[3]>>5)&1)<<3) + (((cryptingBlock[2]>>5)&1)<<2) + (((cryptingBlock[1]>>5)&1)<<1) + (((cryptingBlock[0]>>5)&1)<<0)),
              (byte)((((cryptingBlock[7]>>3)&1)<<7) + (((cryptingBlock[6]>>3)&1)<<6) + (((cryptingBlock[5]>>3)&1)<<5) + (((cryptingBlock[4]>>3)&1)<<4) + (((cryptingBlock[3]>>3)&1)<<3) + (((cryptingBlock[2]>>3)&1)<<2) + (((cryptingBlock[1]>>3)&1)<<1) + (((cryptingBlock[0]>>3)&1)<<0)),
              (byte)((((cryptingBlock[7]>>1)&1)<<7) + (((cryptingBlock[6]>>1)&1)<<6) + (((cryptingBlock[5]>>1)&1)<<5) + (((cryptingBlock[4]>>1)&1)<<4) + (((cryptingBlock[3]>>1)&1)<<3) + (((cryptingBlock[2]>>1)&1)<<2) + (((cryptingBlock[1]>>1)&1)<<1) + (((cryptingBlock[0]>>1)&1)<<0))
            };
            cryptingBlock = temp;
         }

		private void splitBlock()
		{
			//TODO: Implement
		}

		private void functionF()
		{
			//TODO: Implement
			ebox();

			// XOR with key here!

			sbox();	// Paralelization here
			pbox();

			// XOR with left half of the block
			// Right block becomes the left block

		}

		private void inversePermutation()
		{
			//TODO: Implement
		}

		private void ebox()
		{
			//TODO: Implement
		}

		private void sbox()
		{
			//TODO: Implement
		}

		private void pbox()
		{
			//TODO: Implement
		}

    }
}

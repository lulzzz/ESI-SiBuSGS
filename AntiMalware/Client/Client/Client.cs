using System;
using System.ServiceModel;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Management;
using System.Diagnostics;
using System.Security.Cryptography.X509Certificates;
using Interfaces;
using System.Reflection;
using System.Security.Cryptography;
using System.IO;
using System.Collections.Concurrent;
using System.Threading;

using System.Security.Principal;
using System.Security;
using System.IdentityModel;
using Common;
using System.Security.Cryptography;
namespace Client
{
    public class Client : ChannelFactory<IAntiMalwareService>, IClient, IAntiMalwareService
    {
        private int isEventClient = 1;
        private ConcurrentQueue<byte[]> requests;
        private Boolean exit = false;
        private IAntiMalwareService factory;
        private Dictionary<EndpointAddress, Boolean> endPointAddreses = new Dictionary<EndpointAddress, bool>();
        NetTcpBinding binding;
        private byte[] key1 = new byte[8];
        private byte[] key2 = new byte[8];
        private byte[] vector = new byte[8];
        public Client(NetTcpBinding binding, EndpointAddress address)
            : base(binding, address)
        {
            
            string cltCertCN = "wcfclient";

            this.Credentials.ServiceCertificate.Authentication.CertificateValidationMode = System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust;
            this.Credentials.ServiceCertificate.Authentication.RevocationMode = X509RevocationMode.NoCheck;


            /// Set appropriate client's certificate on the channel. Use CertManager class to obtain the certificate based on the "cltCertCN"
            this.Credentials.ClientCertificate.Certificate = Certificate.GetCertificateFromStorage(StoreName.My, StoreLocation.LocalMachine, cltCertCN);
            
            factory = this.CreateChannel();


            requests = new ConcurrentQueue<byte[]>();
            Thread t = new Thread(validateRequests);
            t.Start();
        }

        private void validateRequests()
        {
            byte[] outvalue;
            Boolean tryedReconnecting = false;
            while (!exit)
            {
                while (Requests.TryDequeue(out outvalue))
                {
                    try
                    {
                        Console.WriteLine("Encrypting hash!");
                        RSACrypting.writeHash(outvalue);
                        /*
                        byte[] key1 = new byte[8]; byte[] key2 = new byte[8]; byte[] vector = new byte[8];
                        System.Buffer.BlockCopy(data, 0,key1 , 0, 8);
                        System.Buffer.BlockCopy(data, 8, key2, 0, 8);
                        System.Buffer.BlockCopy(data, 16, vector, 0, 8);

                        /*
                            Triple des!
                         
                        ITripleDES tdes = new MSTripleDES();
                        byte[] resultArray = new byte[40];
                        resultArray = tdes.encrypt(outvalue, key1, key2, vector);

                        Byte[] isval = isValid(resultArray, data);


                        Byte[] newData = RSACrypting.RSAdecrypt(cert, isval);


                        int messageLength = isval.Length - 24;
                        Byte[] message = new Byte[messageLength];

                        //triple des decrypt message




                        Console.WriteLine("Validno: " + isval);
                        */
                    }
                    catch (Exception ex)
                    {
                        Requests.Enqueue(outvalue);
                        Console.WriteLine("Server mi je crkao! Ucini prevezivanje!");
                        int iResult = tryReconnect();
                        if(iResult == -1){
                            exit = true;
                        }
                        if(tryedReconnecting == true)
                        {
                            exit = true;
                        }
                        tryedReconnecting = true;
                        break;
                    }
                }
            }
        }
        private int tryReconnect()
        {
            Stopwatch sw = new Stopwatch();
            sw.Start();
            sw.Stop();
            while(sw.ElapsedMilliseconds < 5000){
                sw.Start();
                try{

                    foreach (KeyValuePair<EndpointAddress, Boolean> pair in endPointAddreses)
                    {
                        if (pair.Value == false)
                        {
                            factory = this.CreateChannel(pair.Key);
                            return 0;
                        }
                    }

                 
                }catch(Exception){
                    sw.Stop();
                }
            }

            Console.WriteLine("Ne mogu vise da uspostavim konekciju sa serverom! Zatvaram se...");
            return -1;
        }
        public Client() { }
        /// <summary>
        /// This method is used to make encrypted message based on TripleDES algorithm. 
        /// <para>data</para> is byte array that represents digital signature that needs to be encrypted.
        /// </summary>
        /// <returns>encrypted digital signature</returns>
        public byte[] encrypt()
        {
            throw new NotImplementedException();
        }
        /// <summary>
        /// This method is used in order to get signature from the applications.
        /// It is based on isEventClient field of the Client class. isEventClient gets its value from the
        /// command line argument. If its value is 1 it means that client waits for applications to start. 
        /// If it is any other value it means that user needs to input path to the .exe file.
        /// </summary>
        public void getSignature()
        {
            if (isEventClient == 1)
            {
                watch();
            }
            else
            {
                getProcessByPath();
            }

        }
        /// <summary>
        /// This method finds certificate based on the location of the .exe or .dll.
        /// </summary>
        private void getProcessByPath()
        {
            String path = null;
            do
            {
                Console.WriteLine("Unesite punu putanju do .exe ili .dll > \n (Za izlaz napisite exit)");
                path = Console.ReadLine();

                if (File.Exists(path))
                {
                    byte[] data = sha256AppHashe(path);
                    if (data != null)
                    {
                        /*
                        StringBuilder hex = new StringBuilder(data.Length * 2);
                        foreach (byte b in data)
                            hex.AppendFormat("{0:x2}", b);
                        
                        Console.WriteLine(hex.ToString());
                        File.AppendAllText(@"C:\Users\mihailo\Desktop\hashes.txt", hex.ToString() + Environment.NewLine);
                       // Console.WriteLine(System.Text.Encoding.UTF8.GetString(data));
                       */
                        requests.Enqueue(data);
                    }

                    Console.WriteLine("Uradio sam.");
                }
                else
                {
                    Console.WriteLine("Niste uneli validnu putanju do fajla.");
                }

            } while (!path.Equals("exit"));
        }

        /// <summary>
        /// This method is used in order to produce events as applications starts or stops.
        /// ManagementEventWatcher class is used in order to subscribe to temporary event notifications based on a specified event query.
        /// WqlEventQuery class is used in order to make WMI( Infrastructure for accessing operations and data in Windows)
        /// event query in WQL(SQL for WMI) format. 
        /// Win32_ProcessStartTrace class indicates that new process is started. 
        /// When event arrives, startWatch_EventArrived handler is called to process it. 
        /// When client closes the application, handlers are stoping.
        /// </summary>
        private void watch()
        {
            ManagementEventWatcher startWatch = new ManagementEventWatcher(new WqlEventQuery("SELECT * FROM Win32_ProcessStartTrace"));
            startWatch.EventArrived += new EventArrivedEventHandler(startWatch_EventArrived);
            startWatch.Start();
            Console.WriteLine("Press any key to exit");
            while (!Console.KeyAvailable) System.Threading.Thread.Sleep(50);
            startWatch.Stop();
        }
        /// <summary>
        /// This method is used in order to process application starting event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void startWatch_EventArrived(object sender, EventArrivedEventArgs e)
        {
            Console.WriteLine("Process started: {0}", e.NewEvent.Properties["ProcessName"].Value);
            Process process = getProcess(makeName(e.NewEvent.Properties["ProcessName"].Value.ToString()));
            if (process != null)
            {
                byte[] data = sha256AppHashe(process.MainModule.FileName);
                Console.WriteLine(System.Text.Encoding.UTF8.GetString(data));

                if (data != null)
                {
                    /*
                    StringBuilder hex = new StringBuilder(data.Length * 2);
                    foreach (byte b in data)
                        hex.AppendFormat("{0:x2}", b);

                    Console.WriteLine(hex.ToString());
                    File.AppendAllText(@"C:\Users\mihailo\Desktop\hashes.txt", hex.ToString() + Environment.NewLine);
                    // Console.WriteLine(System.Text.Encoding.UTF8.GetString(data));
                    */
                    requests.Enqueue(data);
                }


                Console.WriteLine("Uradio sam.");
            }
        }
        private byte[] sha256AppHashe(String path)
        {
            FileStream filestream;
            SHA256 mySHA256 = SHA256Managed.Create();
            try
            {
                filestream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                filestream.Position = 0;

                byte[] hashValue = mySHA256.ComputeHash(filestream);

                return hashValue;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Fajl vec otvoren!");
                return null;
            }

        }
        /// <summary>
        /// Based on started event and its full name( having .exe in the end) it is making name without .exe.
        /// </summary>
        /// <param name="wholeName"></param>
        /// <returns>name without .exe</returns>
        private String makeName(String wholeName)
        {
            return wholeName.Substring(0, wholeName.Length - 4);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="name"></param>
        /// <returns>process if it exists, NULL if the process doesn't exist!</returns>
        private Process getProcess(String name)
        {
            Process retVal = null;
            try
            {
                retVal = Process.GetProcessesByName(name)[0];
            }
            catch (Exception ex)
            {
                Console.WriteLine("There is no process started by the given name.");
            }
            return retVal;
        }
        /// <summary>
        /// Property for setting isEventClient field.
        /// </summary>
        public int IsEventClient
        {
            get
            {
                return isEventClient;
            }
            set
            {
                isEventClient = value;
            }
        }

        public Byte[] isValid(Byte[] hash)
        {
            try
            {
                factory.isValid(hash);
                return null;
            }
            catch (Exception ex)
            {
                throw ex;
            }

        }
        static string GetString(byte[] bytes)
        {
            char[] chars = new char[bytes.Length / sizeof(char)];
            System.Buffer.BlockCopy(bytes, 0, chars, 0, bytes.Length);
            return new string(chars);
        }
        public byte[] exchangeData(byte[] data)
        {
            try
            {
                /*

                    RSA CRYPTING KEYS AND VECTOR
                 */
                X509Certificate2 cert = Certificate.GetCertificateFromStorage(StoreName.My, StoreLocation.LocalMachine, "wcfservice");
                data = RSACrypting.RSAencrypt(cert);
                System.Buffer.BlockCopy(data, 0, key1, 0, 8);
                System.Buffer.BlockCopy(data, 8, key2, 0, 8);
                System.Buffer.BlockCopy(data, 16, vector, 0, 8);

                Byte[] response = factory.exchangeData(data);

                ITripleDES tdes = new Security.TripleDES();
                Byte[] decrypted = tdes.decrypt(response, key1, key2, vector);
                String str = GetString(decrypted);
                return response; 
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.StackTrace);
                return null;
            }
        }

        public ConcurrentQueue<byte[]> Requests
        {
            get
            {
                return requests;
            }
            set
            {
                requests = value;
            }
        }

        public Dictionary<EndpointAddress, Boolean> EndPointAddreses
        {
            get
            {
                return endPointAddreses;
            }
            set
            {
                endPointAddreses = value;
            }
        }

        public NetTcpBinding Binding
        {
            get
            {
                return binding;
            }
            set
            {
                binding = value;
            }
        }
    }
}
